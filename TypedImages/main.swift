//
//  main.swift
//  TypedImages
//
//  Created by Mathijs Kadijk on 11-12-14.
//  From: http://github.com/mac-cain13/TypedImages
//  License: MIT License
//

import Foundation

// MARK: Helper functions

func projectDirectoryURL(fileManager: NSFileManager, processInfo: NSProcessInfo) -> NSURL! {
  let processInfoArguments = processInfo.arguments
  if processInfoArguments.count >= 2 {
    return NSURL(fileURLWithPath: processInfoArguments[1] as String)
  }

  return NSURL(fileURLWithPath: fileManager.currentDirectoryPath)
}

func findAssetsFoldersRecursively(fileManager: NSFileManager, urlToScan: NSURL) -> [NSURL] {
  let errorHandler: (NSURL!, NSError!) -> Bool = { (url, error) in
    println("WARN: \(url) could not be enumerated due error: \(error)")
    return true
  }

  var assetFolders = [NSURL]()

  if let enumerator = fileManager.enumeratorAtURL(urlToScan, includingPropertiesForKeys: [NSURLIsDirectoryKey], options: NSDirectoryEnumerationOptions.SkipsHiddenFiles|NSDirectoryEnumerationOptions.SkipsPackageDescendants, errorHandler: errorHandler) {

    while let enumeratorItem: AnyObject = enumerator.nextObject() {
      if let url = enumeratorItem as? NSURL {
        var isDirectoryValue: AnyObject?
        url.getResourceValue(&isDirectoryValue, forKey: NSURLIsDirectoryKey, error: nil)

        if let isDirectory = isDirectoryValue as? Bool {
          if isDirectory && url.absoluteString!.pathExtension == "xcassets" {
            assetFolders.append(url)
            enumerator.skipDescendants()
          }
        }
      }
    }
  }

  return assetFolders
}

struct AssetFolderInfo {
  let codeFileURL: NSURL
  let name: String
  let imageInfo: [(varName: String, imageName: String)]

  init(url: NSURL, fileManager: NSFileManager) {
    name = sanatizeForSwiftName(url.lastPathComponent!.stringByDeletingPathExtension.capitalizedString)
    self.codeFileURL = url.URLByDeletingLastPathComponent!.URLByAppendingPathComponent(name + ".generated", isDirectory: false).URLByAppendingPathExtension("swift")

    let contents = fileManager.contentsOfDirectoryAtURL(url, includingPropertiesForKeys: nil, options: NSDirectoryEnumerationOptions.SkipsHiddenFiles, error: nil) as [NSURL]
    imageInfo = distinct(contents.map { $0.lastPathComponent!.stringByDeletingPathExtension })
      .map { (varName: sanatizeForSwiftName($0), imageName: $0) }

    if imageInfo.count != contents.count {
      println("WARN: Asset folder \(url) has \(contents.count - imageInfo.count) duplicate images.")
    }
  }
}

func sanatizeForSwiftName(name: String) -> String {
  var components = name.componentsSeparatedByString("-")
  let firstComponent = components.removeAtIndex(0)
  return components.reduce(firstComponent) { $0 + $1.capitalizedString }
}

func generateTypedAssetCode(assetFolderInfo: AssetFolderInfo) -> String {
  return "//\n" +
    "//  \(assetFolderInfo.name).generated.swift\n" +
    "//  GENERATED FILE, DO NOT EDIT.\n" +
    "//\n" +
    "//  Generated by TypedImages. See: http://github.com/mac-cain13/TypedImages\n" +
    "//\n" +
    "\n" +
    "class \(assetFolderInfo.name) {\n" +
    assetFolderInfo.imageInfo.reduce("") { $0 + "  class var \($1.varName): UIImage! { return UIImage(named: \"\($1.imageName)\") }\n" } +
    "}\n"
}

func writeCode(code: String, # toURL: NSURL) {
  println("Writing \(toURL)...")
  code.writeToURL(toURL, atomically: true, encoding: NSUTF8StringEncoding, error: nil)
}

func distinct<T: Equatable>(source: [T]) -> [T] {
  var unique = [T]()
  for item in source {
    if !contains(unique, item) {
      unique.append(item)
    }
  }
  return unique
}

// MARK: Procedure

let defaultFileManager = NSFileManager.defaultManager()
let directoryURL = projectDirectoryURL(defaultFileManager, NSProcessInfo.processInfo())

findAssetsFoldersRecursively(defaultFileManager, directoryURL)
  .map { AssetFolderInfo(url: $0, fileManager: defaultFileManager) }
  .map { (url: $0.codeFileURL, code: generateTypedAssetCode($0)) }
  .map { writeCode($0.code, toURL: $0.url) }
